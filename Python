python变量：
变量类型：str（字符串类型） int（整数类型）float（浮点类型）bool（布尔类型）
str：用单引号，双引号，三引号所包含的长串字符
int：数字整数
float：可以包含有小数的数字
bool：对错判断类型
int，float，bool：属于同一字符类型，可以相互运算
str不能与int，float，bool直接运算，得通过格式转换才能相互运算
格式化转换int（str）就可以转换为整数类型，其他同理
输出类型：%s(字符串)，%d（十进制整数）（%06d 6位不足位置补0），%.f(小数)（%.2f 两位小数）%%（输出%）

python运算符：
算术运算符：+（相加）、-(相减)、*（相乘）、/（相除）、//（取整），%（取余），**（幂）
比较运算符：==（判断是否相等）、!=（判断是否不相等）、>(判断是否大于)、<(判断是否小于)、>=(判断是否大于等于)、<=（判断是否小余等于）
逻辑运算符：and（与，都真为真）、or（或，一个真即为真）、not（非，对数据取非）
赋值运算符：=（a = b）、+=（a = a + b）、-=（a = a - b）、/=（a = a/b）、
           //=（a = a//b）、*=（a = a*b）、%=（a = a%b）、**=（a = a**b）
运算的优先级：
算术的优先级最高： 幂的优先级最高 → 乘除、取整、取余 → 加减
比较的优先级第二： >、<、>=、<=最高 → ==、!=
赋值的优先级第三： 所有赋值符优先级一样高
逻辑的优先级最低： 逻辑符的优先级也一样高

if分支:
  if的基本语句结构：if 条件（判断类型）：
                      语句块（满足条件时运行的）
                 else：
                      语句块（不满足条件时运行的）
  if多分支的语句结构：if 条件1（判断类型）：
                      语句块（满足条件1时运行的）
                  elif 条件2 （判断类型）：
                      语句块（不满足条件1，满足条件2时运行的）
                  elif 条件3 （判断类型）：
                      语句块（不满足条件1，2，满足条件3时运行的）（以下同理）
                  else：
                      语句块（不满足条件时运行的）
  if里的条件还可以用逻辑运算符联立判断：（if a>0 and b<0：）其他和上面一样
循环：while，for
while循环：
  基本结构：
   while 条件：
       语句块（条件满足就执行，
               执行完就又回到while后面的条件继续判断，
               如果条件还满足就继续执行此语句块，
               否则条件不满足就结束while循环）
   循环：基本四大要素：条件、循环体（语句块）、改变循环变量的值（使循环不是死循环）、循环变量初始化
   循环变量初始化
   while 条件:
       循环体
       改变循环变量的值
   while里面还可以用break、continue两个执行语法
   break：当循环中遇到break就停止本层循环，继续循环下面的语句（只能用在循环里面）（想当于直接退出整个while循环）
   continue:结束本次循环，继续下一次的循环（只能用在循环里面）（跳过一次while循环的结果，进行下一次的while循环）
   也可以用else来让while循环输出，主要是为了书写看上去方便简洁，跟不写else在循环体外面直接输出一个意思
   
for循环：
    for item in items:
        取出items里面的数据
    读取字符串里面的每一个字母（读取完毕后退出for循环，items算是个序列然后依次读取每一个项，然后用对应的项的数据、去做运算、执行语句）
  range()函数是得到一串连续的数字，eg：range（1，5）就是读取1、2、3、4最右边的5不取
  for也可以用break、continue、else，用法相同
  嵌套循环：
  for里面可以加for也可以加while，同理while也是。
  然后依次执行第一个for和第二个for
  
随机数:
  python内使用随机数需要使用随机数的模块--"工具包": import random
  random的几种用法: 1) 随机小数
                      random.random() #获取大于0且小于1 之间的小数
                      random.uniform(a,b) #获取大于a小于b-1的小数
                   2) 随机整数
                      random.randint(a,b) #获取a到b之间的整数包括a,b
                      random.randrange(a,b) #获取a到b之间的整数不包括b
                      random.randrange(a,b,2) #获取a到b之间的奇数不包括b
                   3) 随机选择一个返回值
                      random.choice([1,"23",[4,5]]) # 返回1或者"23"或者[4,5]
                   4) 随机选择多个返回值,返回的个数为函数的第二个参数
                      random.sample([1,"23",[4,5]],2) # 返回列表元素任意2个组合作为一个列表
                   5) 打乱顺序排序
                      random.shuffle(list)  #打乱列表list中的元素顺序
列表:
    列表中每个元素的数据类型可以各不相同,创建可以直接用a_list=[],方括号里写元素,也可以用list将字符串转换成列表;
    删除: del a_list #删除整个列表    del a_list[i] #删除a_list的第i位上的__元素
          a_list.pop() #默认删除列表中最后一位的元素,在括号里给予相应位置时,_移除相应位置的元素,并且返回所删元素的值
          a_list.remove() #删除首次出现的指定元素,括号内写元素名,列表中与元_素名对应的元素从左到右删_除第一个对应的元素
          a_list.clear() #把列表清空变成空列表 []
    增加: a_list.append(a) #在列表尾部追加一个元素a,不改变列表的内存地址,属于原地操作
          a_list.insert(i,a) #在列表的第i位插入一个元素a,不改变列表的内存地址,属于原地操作
          a_list.extend(b_list) #将另一个可迭代对象的所有元素添加至列表对象的尾部,不改变列表的内存地址,属于原地操作
          +和* #不是为列表添加新元素,而是创建一个新的列表,不属于原地操作 b_list = a_list + [a] 、 b_list = a_list*2
    访问与计数: a_list.count(a) #列表a_list中a出现的次数
                a_list.index(a) #列表中a首次出现的位置,如果没有则抛出异常
                a in a_list #返回一个bool值,如果a在a_list中则为True,不在则为Flase
         
    排序: a_list.sort() #默认升序排列
          a_list.sort(reverse = True) #降序排列
          a_list.reverse() #逆序排列 以上三种均属于原地操作
          sorted(a_list) #和a_list.sort()功能相同,但是不属于原地操作,产生了新的列表
          reversed(a_list) #和a_list.reversed()功能相同,但是不属于原地操作,产生了新的列表
    用于序列的常用内置函数
    len(a_list) #返回列表a_list中元素的个数,同样适用于元组,字符串,字典,集合等
    max(),min() #返回列表中的最大或最小的元素,同样适用于元组,字典,集合,range等
    sum(a_list) #对列表a_list中的元素求和
    zip() #返回可迭代的zip对象 eg: a_list = [1,2,3]
                                  b_list = [4,5,6]
                                  c_list = zip(a_list,b_list)
                                  print(c_list) → 0x0000000003728908 #zip不是一个列表
                                  print(list(c_list)) → [(1,4),(2,5),(3,6)]
    enumberate() #返回列表的索引值,元素 eg: for i,ele in enumberate(['a','b'])
                                           print(i,ele) → (0,'a')
                                                          (1,'b')
    遍历列表的三种方式: a = ["a","b"]
                      for i in a
                          print(i)
                      for i in range(len(a)):
                          print(i,a[i])
                      for i,ele in enumberate(a):
                          print(i,ele)
                      
    列表推导式: #使用非常简洁的方式来快速生成满足特定需求的列表,代码具有很强的可读性;
                 #语法格式: [表达式 for 变量 in 序列或迭代对象] 
                 eg: lis = [i for i in range(100)] → 依次输出 0 到 99
                     vec = [[1,2,3],[4,5,6],[7,8,9]]
                     list = [num for ele in vec for num in ele] → [1,2,3,4,5,6,7,8,9]
    列表切片: #使用索引获取列表的元素: eg:colors = ["red","blue","green"]
                                        colors[0] == "red" #True
                                        colors[1] == "blue" #True
                                        colors[-1] == "green" #True #python中有序序列都支持负向索引
             #列表切片的操作: python中有序序列都支持切片,如字符串,元组.
                             格式: li[start:end:step]#step为正的时候,从左往右切,为负的时候从右往左切
                             eg: li=["A","B","C","D"]
                                 t = li[0:3] → ["A","B","C"] #起点的0索引可以省略,t = li[:3]
                                 t = li[2:] → ["C","D"] #省略end,则切到末尾
                                 t = li[0:4:2] → ["A","C"] #从li[0]到li[3],设定步长为2
             #使用切片来原地修改内容: aList[len(aList):]=[a] #在列表aList尾部追加a元素
                                    aList[:3]=[1,2,3] #替换前3个元素
                                    aList[:3]=[] #删除前3个元素
             #使用del与切片的结合来删除列表元素: del aList[:3] #删除列表内前3个元素
                                               del aList[::2] #隔两位删一个(删除偶数位置上的元素)
             #切片返回的列表元素的浅复制: #浅复制:生成一个新的列表,并把原列表中的所有元素的引用都复制到新的列表中
                                         与赋值的区别在于 浅复制两个列表内的元素完全相同,但是内存地址不一样,修改其中一个不会影响另一个
                                         格式: bList = aList[::] #把aList中的所有元素复制到bList,但是aListd、bList互相不影响

元组: 元组属于不可变序列,一旦创建就不能修改它的元素,元组的所有元素都存放在一对圆括号里,元素之间以逗号隔开
      eg: x = (1,2,3)  #把变量x赋值元组(1,2,3)
          x = (1,)     #创建只有一个元素的(1)元组
      tuple函数: 用tuple函数可以把其他的序列变成元组,eg:tuple("abcdef") → ("a","b","c","d","e","f") #也可以用于列表等
      删除: 可以使用del删除整个元组,但是不能删除元组内的元素

      元组和列表的区别: 元组中的数据一旦定义就不允许更改
                       元组没有append()、extend()、insert()等方法,无法向元组中添加元素
                       元组没有remove()或pop()方法,也无法对元组中的元素做del操作,不能从元组中删除元素
                       从效果上看, tuple()冻结列表,list()融化元组
 
      元组的优点: 元组的速度比列表更快
                  元组对不需要改变的数据进行"写保护"将使得代码更安全
                  元组可用作字典键(特别是包含字符串、数值和其他元组的不可变数据的元组).元组有时还作为函数的返回值返回(返回多个值)
字符串: 字符串切片: 和元组的切片大致相同.取不到的时候返回""空字符串
       字符串常用的函数: s.upper() #字符串s全部大写
                        s.lower() #字符串s全部小写
                        s.startswith("a") #判断字符串s是否以"a"开头 返回bool值
                        s.endswith("b")   #判断字符串s是否以"b"结尾 返回bool值
                        s.find("c")       #通过元素找到元素时,返回首次出现该元素的索引(可切片),找不到返回-1
                        s.index("c")      #通过元素找到元素时,返回首次出现该元素的索引(可切片),找不到抛出错误
                        s.strip()         #默认删去字符前后两端的空格,换行符,tab,如果在括号里加值,则删除字符前后两端的对应值,没有则不删除
                        s.split()         #默认把字符串s按空格为标识分割成列表,如果在括号里写值,则按括号里的值为标识分割,如果写成s.split(,1)
                                           不管空格有多少个,只分割一次
                        "".join(aList)    #把列表aList里的所有元素无间隔链接成一串字符串,如果在引号里写了东西,则按照写的东西链接起来
                        s.isalnum()       #如果字符串s内所有字符都是数字或者字母或者数字字母混合组合,则返回真,否则返回假
                        s.isalpha()       #如果字符串s内所有字符都是字母,则返回真,否则返回假
                        s.isdigit()       #如果字符串s内所有字符都是数字,则返回真,否则返回假
                        s.islower()       #如果字符串s内所有字符都是小写,则返回真,否则返回假  
                        s.isupper()       #如果字符串s内所有字符都是大写,则返回真,否则返回假
                        s.istitle()       #如果字符串s内所有单词首字母都是大写,则返回真,否则返回假
                        s.isspace()       #如果字符串s内所有字符都是空白字符,则返回真,否则返回假
                        s.count(a)        #计算字符串s中a字符出现的次数,s.count(a,b)规定范围从0到第b位中a出现的次数
                        s.replace()       #替换字符串s中指定的字符,eg:s = "a曰,学而时习之,ad"
                                                                    print(s.replace("a","孔子",1)) #只替换第一个"a"  
                                                                    print(s.replace("ad","不亦说乎"))#替换"ad"为"不亦说乎"
                        s.capitalize()    #字符串s中首字母大写
                        s.center(50,"*")  #输出居中,可设置总长度,可设置填充物(输出总长50个字符,空白处用"*"填充)
                        s.title()         #非字母隔开的每个字母首字母大写
      字符串是不可变量,不支持直接通过下标修改内部值
字典: 字典是包含若干"键:值"元素的无序可变序列,字典中每个键都是唯一的,每个元素的键和值使用冒号分隔,元素之间用逗号隔开,所有元素放在一对大括号里面
      字典内的键值可以是任意不可变数据,比如整数,字符串,元组等等
      字典的创建: a_dict = {} / a_dict = dict() #两者都是创建一个空字典,后者可以用已有数据变成字典
                 eg:a = ["a","b"]
                    b = [1,2]
                    a_dict = dict(zip(a,b)) → {"a":1,"b",2} #利用已有数据创建字典
                    b_dict = dict(a=1,b=2) → {"a":1,"b",2}  #根据给定的键、值创建字典     
                    c_dict = dict.fromkeys(["a","b"]) → {"a":None,"b",None} #以给定内容为键,创建值为空的字典
      字典的读取: 以键作为下标读取字典的值,若键不存在抛出异常
                    a_dict = {"a":1,"b":2}
                 eg:a_dict["a"] → 1
                 使用字典对象的get方法获取指定键对应的值,并且可以在键不存在的时候返回指定值
                 eg:print(a_dict.get("add")) → None
                    print(a_dict.get("add","pupu")) → pupu
                 使用字典对象的items()方法可以返回字典的键,值对列表
                 eg:for item in a_dict.items():
                        print(item) → ("a",1) ("b",2)
                    for key in a_dict: #不加特殊说明,默认输出键
                        print(key) → a b
                 使用字典对象的keys()方法可以返回字典的键列表    
                 eg:print(a_dict.keys()) → dict_keys(["a","b"])
                 使用字典对象的values()方法可以返回字典的值列表 
                 eg:print(a_dict.values()) → dict_values([1,2])
                 使用字典对象的setdefault()方法可以返回指定键对应的值,如果字典中不存在该键,就添加一个元素并设置该键对应的值
                 eg:a_dict.setdefault("c",3) #增加新元素
                    print(a_dict.setdefault("c",3)) → 3
                    print(a_dict) → {"a":1,"b":2,"c":3}
      字典元素的添加: 1.当以指定键为下标字典赋值时,若键存在,则可以修改该键的值,若不存在,则标识添加一个键,值对.
                     eg: a_dict["c"] = 4 → {"a":1,"b":2,"c":4}
                     2.使用字典对象的update方法将另一个字典的键,值对添加到当前字典对象
                     eg: a_dict.update({"d":5,"e":6}) → {"a":1,"b":2,"c":4,"d":5,"e":6}
      字典删除: 1.使用del删除整个字典,或者字典中的指定元素
               2.使用pop()和popitem()方法弹出并删除指定元素 #pop()是指定删除,返回删除键对应的值.popitem()随机删除,返回删除键和值.
               3.使用clear()方法清空字典中所有元素
      判断一个key是否在字典中:使用in方法:#也可以用 not in
                            eg:print("a" in a_dict)
                               print("a" in a_dict.keys()) #两个返回值都为True
                            
      遍历字典:1.遍历key值:eg:for key in a_dict:
                                 print(key+": {}".format(a_dict[key])) → a:1 b:2 c:4 d:5 e:6
                             for key in a_dict.keys():
                                 print(key+": {}".format(a_dict[key])) → a:1 b:2 c:4 d:5 e:6
              2.遍历value值:eg:for value in a_dict.values():
                                 print(value) → 1 2 4 5 6
              3.遍历字典项:eg:for item in a_dict.items():
                                 print(item) →  ("a":1) ("b":2) ("c":4) ("d":5) ("e":6)
              4.遍历字典键,值:for key,value in a_dict.items()
                                 print(key,value) → a 1 b 2 c 4 d 5 e 6
                            for (key,value) in a_dict.items() #和上面完全相同
                                 print(key,value) → a 1 b 2 c 4 d 5 e 6
       有序字典:需要导入内置包:collection eg: import collections
                                            x = collections.OrderedDict()    
                                            x["a"] = 3 #1
                                            x["b"] = 4 #2
                                            x["c"] = 5 #3
                                            print(x) → OrderedDict([('a', 3), ('b', 4), ('c', 5)])#1#2#3固定顺序
       字典推导式:表达式:{key_expr:value_expr for value in collection if condition} #结合列表推导式去推导                                    
集合: 无序可变的序列,使用一对大括号界定,元素不可重复,集合内元素是唯一的,集合中只能包含数字,字符串,元组等不可变类型的数据,不能包含
      列表,字典,集合等可变序列;
      集合的创建:eg:a_set = {}#创建空的集合 a_set.add(1) → a_set={1} #add方法如果集合里有所添加的值,则什么都不改变
                   也可以用set()函数来创建集合,b_set = set()         #创建一个空集合,括号里写其他类型的数据都可以转换为集合,自动消重
      集合的删除:del直接删除整个集合,pop()先对集合从小到大排序再删除首位置的元素,remove()直接删除指定的元素,clear()清空集合
      集合的添加:add()#如上,update()#直接添加一个集合给之前的集合,消重,排序.#上面的删除和添加的方法均为原地操作
      集合的操作:a_set|b_set #并集也可以写成a_set.union(b_set)
                a_set&b_set #交集也可以写成a_set.intersection(b_set)
                a_set-b_set #差集也可以写成a_set.difference(b_set)
                .issubset() #测试是否为子集
                >,<可以比较集合的包含关系
     集合推导式:eg:s = {x.strip() for x in (" he"," she ","i ")}
                  print(s) → {"i","she","he"}
函数: 格式def 函数名(参数列表):             #函数名命名规则,必须以字母或者下划线开头,可以包含任意字母,下划线或者数字组合,不能使用任何标点符号;
             函数体                         函数名是区分大小写的;函数名不能是保留字         
      形参: 形式参数,不是实际存在的值,是虚拟变量;在定义函数和函数体的时候使用形参,目的是在函数调用接收实参
      实参: 实际参数,调用函数时传给函数的参数,可以是常量,变量,表达式,函数传给形参
      区别: 形参时虚拟的,不占用内存空间,形参变量只有在被调用时才分配内存单元,实参是一个变量,占用内存空间,数据传送单向,实参传给形参,不能形参传给实参
      好处: 1.代码重用 2.便于修改 3.易扩展
      函数的参数: 1.必须参数 #必须参数得以正确的顺序传入函数,和声明一样;如果def fuction(name,age)那么一定得先传入name的值,在传入age的值
                 2.关键字参数 #关键字参数可以用声明时的关键字来传入参数;eg:fuction(age = 18,name = "aabb")
                 3.默认参数,可以在声明时就给参数赋予默认值,但是必须写在()最后一位
                 4.不定长参数,(*tuples)#多个未命名的变量参数(**kwargs)#多个已命名的参数
      函数的返回值: 函数执行时遇到return语句,就会停止执行并返回结果,如果未指定return则返回为None,如果return多个对象,解释器会把多个对象组装成
                   一个元组作为整体输出. 
      高阶函数: 至少满足下列一个条件的函数:接受一个或者多个函数作为输入 输出一个函数
      函数的作用域: local:局部作用域,函数中定义的的变量;enclosing:外层作用域,嵌套函数中,父级函数中定义的变量;global:全局变量,函数体外定
                         义的变量,和函数在同一个模块面的变量;build-in:内置作用域,固定模块里的变量,比如int,bytearray等.搜索变量的优先级
                         local>enclosing>global>build-in,也就是LEGB.
      作用域的产生: def,class,lambda是可以引入新的作用域的;
      变量的修改: 全局变量要在函数内部修改的话得加入global关键词,把全局变量引入函数内部,才能进行修改;要修改外层作用域的变量参数得在内层函数内
                 引用nonlocal关键词,才能对外层作用域的变量进行修改;否则无法进行修改
      递归函数: 必须要有一个明确的结束条件,每次进入深层次递归时,问题规模相比上一次有所减少.递归的效率不高,但是有时候必须用递归函数才能完成;
      匿名函数: 格式: calc(函数名) = lambad(关键词) n(参数):n**n(返回值);参数可以有多个参数,匿名函数有限制,只能有一个表达式,不用写return
                返回值就是该表达式的结果;
                匿名函数的好处: 因为函数没有名字,不用担心函数名冲突;匿名函数也是一个函数对象,也可以把匿名函数赋值给一个变量,在通过变量调用函数
                               匿名函数函数体简单!使用匿名函数可以减少代码量;
                内置函数: 内置函数有很多,这里将几个主要的函数;
                         1. map 函数: 接受两个参数,一个得是可迭代的对象,map将传入的函数依次作用到序列的每个元素,并把结果作为一个新的迭代返回
                                      遍历序列,对序列中每个元素进行函数操作,最终获取新的序列;
                                      eg: li = [1,2,3,4,5,6,7,8,9]
                                          print(list(map(lambda x: x*x,li))) → [1,4,9,16,25,36,49,64,81]
                         2. reduce 函数: 把一个函数作用一个序列[x1,x2,x3,...]上、这个函数必须接受两个参数,reduce把结果继续和序列的下一个元素
                                         做累积计算;
                                      eg: from fuctools import reduce
                                          li = [1,2,3,4,5,6,7,8,9]
                                          print(reduce(lambda x,y: x*y,li)) → # 9!
                         3. filter 函数: 接受一个函数和一个序列,fiter()把传入的函数依次作用于每个元素,然后根据返回值时Ture还是False决定是否保留
                                         对序列中的元素进行筛选,获取符合条件的序列
                                      eg: li = [1,2,3,4,5,6,7,8,9]
                                          print(list(filter(lambda x: x%2 == 1,li))) → [1,3,5,7,9]
                                      
                         4. sorted 函数: 接受一个key函数来实现对可迭代对象进行自定义排序;可迭代对象:列表,字符串,元组,集合和字典;
                                         key: 接受一个函数,根据函数的返回值,进行排序
                                         reverse: 排序方向,默认从小到大, reverse = True为逆向
                                     eg: li = [-21,-12,5,9,36]
                                         print(sorted(li,key = lambda x:abs(x))) → keys 排序结果 #[5,9,12,21,36] 
                                                                                        最终结果 → [5,9,-12,-21,36]
               函数式编程: 是一种编程范式; 我们常见的编程范式有: 命令式编程,函数式编程,常见的面对对象编程也是一种命令式;
                          函数式编程相当于用一个个函数完成一段编程;
                          eg: 把number = [2,-5,9,-7,2,5,4,-1,0,-3,8]中的正数求平均值;
                             命令式编程: number = [2,-5,9,-7,2,5,4,-1,0,-3,8]
                                        count= 0
                                        sum = 0
                                        for i in range(len(number))
                                            if number[i]>0:
                                                count += 1
                                                sum += number[i]
                                        print sum,count
                                        
                                        if count>0:
                                            average = sum/count
                                        print (average)
                                        
                             函数式编程: number = [2,-5,9,-7,2,5,4,-1,0,-3,8]
                                        from fuctools import reduce
                                        positive = filter(lambda x: x>0, number)
                                        average  = reduce(lambda x,y: x+y, positive)/len(positive)
                                        
                                        print (average)
                             
                             差别一目了然,函数式编程更加简洁,易懂

               将函数存储在模块中: 方法: 1.导入整个模块 import + 存储模块的文件名 #模块文件名必须和导入文件放在同一个包内
                                       2.导入特定的函数 from + 存储模块的文件名 + import + 模块内的函数名(可以导入多个,用逗号隔开)
                                       3.为导入的特定函数赋予新的名字 from + 存储模块的文件名 + import + 模块内的函数名 + as + 新名称
                                       4.导入模块内所有的函数 from + 存储模块的文件名 + import + * 
               
               函数文档字符串: 给函数写说明#用"""三引号标注:eg:def text(msg):
                                                            """
                                                                函数名: text
                                                                功能: 测试
                                                                参数: 无
                                                                返回值:无
                                                            """
                                                                print("函数输出成功" + msg)
                                                            text("hello")
                                                            print(help(test))#在交互模式下可以使用help查看函数说明,该界面会调到说明界面,需要
                                                                              输入q退出
                                                            print(test.__doc__)#使用.__doc__属性查看,说明直接显示在交互界面上
                                                            
面对对象: 类和对象; 万物皆可对象;
         类是一个抽象的概念,是个模板,比如:"人"所有的人都能规定在"人"这个类里面;
         对象是一个你能够看得到,摸得着的实体:如"人"类中的某一个个体,例如"你自己";
         对象的属性: 对象具有的特征,比如你的名字,长相,年龄,性别等等;
         对象的行为: 对象执行的操作,比如你去睡觉,买东西,吃饭等等;
         类的定义:class A: #A是类名
                     #给类的每一个对象加初始属性
                     #self的含义:外部对象调用的自身的参数
                     def __init__(self,name):   #初始化方法,这个函数下面写的都为初始化的内容,也可以外部加参数,例如这里加的name
                         self.count = 0         #意思是 count的初始值是0 定义后后面都可以直接使用它
                         self.name = name       #意思是初始的name为外部输入的name
                     #类中对象的行为
                     def eat(self):             #这里面也可以加多的参数,不过self必须加
                         self.count += 1           #调用self.count且改变它的值
                         print("%s吃东西"%self.name)#调用了对象初始属性中的name
                     
                     def __str__(self):
                         return str(self.count) #只能返回str格式的参数
                     
                 a = A("Tom")   #调用类A,a对应self,"Tom"对应name;__init__方法不用调用可以直接使用,a为实例对象
                 a.eat()        #调用eat方法,类中函数的调用用实例对象.函数就好了
                 print(a)       #输出__str__中的返回值 如果不写__str__方法的话a的返回值会返回<__main__.A object at 0x000001E6687E7080>
                                 用__str__方法的话,可以直接写print(a)因为__str__方法也不需要调用
          
          面对对象的好处:和直接在模块中写函数,在类中写包装性更好,主体直接调用就好了,可变性也比较强,易于修改;
                        拿公司老板和员工做例子就是:
                        外部调用代码好比老板面向过程中函数好比员工，让员工完成-一个任务，需要老板不断的干涉，大大影响了老板的工作效率。
                        面向对象中对象好比员工，让员工完成一个任务，老板只要下命令即可，员工可以独挡一面，大大节省了老板的时间。        
          
          私有属性: 只能在对象的内部被使用,不能被外部访问到;定义属性名或者方法前增加两个下划线__就能定义一个私有属性;
                   实际开发中私有属性也不是一层不变的,有专门的方法可以让外部能够操作私有属性:
                   自定义get,set方法提供私有属性的访问:
                   eg:class Person:
                          def __init__(self,name,age):
                              self.name = name
                              self.__age = age
                          
                          #定义对私有属性的get方法,获取私有属性
                          def getAge(self):
                              return self.__age
                              
                          #定义对私有属性的set方法,对私有属性重新赋值
                          def setAge(self,age):
                              self.__age = age
                              
                      person1 = Person("Tom",19)
                      person1.setAge(20)
                      print(person1.name,person1.setAge()) #Tom 20
                      
                  使用property标注提供私有属性的访问
                  eg:class Person:
                          def __init__(self,name,age):
                              self.name = name
                              self.__age = age

                          @property                    #@property下面默认跟的是get方法,如果设置成set会报错
                          def age(self):
                              return self.__age
                          
                          @age.setter                  #使用上面函数名.setter,不是property.setter
                          def age(self,age):
                              self.__age = age
                      
                      #用了标注提供访问后,改变的时候可以直接.函数名不用加括号
                      person1 = Person("Tom",19)
                      person1.age = 20
                      print(person1.name,person1.age) #Tom 20
          
           类对象,实例对象 #类对象:类名
                          #实例对象:类创建的对象
           类属性:类对象所拥有的属性;它被类对象,实例对象所共有,在内存中只存在一个副本;对于共有的类属性,在类外可以通过类对象和实例对象访问
           实例属性:实例对象特有的属性,类对象不能拥有,在类外定义的,用实例对象进行操作的,不能通过类对象调用
           
           如果在类外修改类属性,必须通过类对象去引用然后修改;如果通过实例对象去引用会产生一个同名的实例属性,这种方式修改的是实例属性,不会
           修改类属性;并且通过实例属性调用的话,会屏蔽同名的类属性.
           
           类方法:类对象拥有的方法,需要用@classmethod来标识其为类方法,对于类方法,第一个参数必须是类对象,一般以cls作为第一个参数(可以用其
           它的变量,但是这里是大部分人都习惯cls,所以方便理解建议采用cls),能够通过实例对象和类对象去访问,就可以通过实例对象去修改类属性;
           
           静态方法:用装饰器@staticmethod来进行修饰,不需要定义参数;
           
           继承: 子类自动继承父类的所有属性和方法,子类也可以自己创建属于自己的属性和方法;#继承父类定义的默认属性时,用super().__init__()
                 方法进行调用;
           
           __new__方法:主要的作用:1.在内存中为对象分配空间 2.返回对象的引用(即对象的内存地址)
                       如果写了__new__方法就必须return super().__new__(cls)不然后面的__init__不会执行
                       一般使用系统object中的__new__方法,不自己去定义;单例模式的时候会使用到__new__方法
           
           object: 隐式父类,里面有__new__方法,且调用的时候默认调用,不用加super;
           
           单例模式: 不管创建多少个实例对象,都指向一个内存地址
                     eg:class A(object):
                                 _instance = None
                                 def __new__(cls,*args,**kwargs):
                                     if A._instance == None:
                                          A._instance = super().__new__(cls)
                                     return A._instance
                        a1 = A()
                        print(id(a1))
                        a2 = A()
                        print(id(a2)) #id相同
                        
变量: 可变变量: 列表list,字典dict,自定义类型(class定义的类型)
      不可变变量: 数字类型,字符串str,元组tuple

异常处理: 异常: 程序运行时,如果Python解释器遇到一个错误,会停止程序的运行,并且提示错误信息;
               #程序停止执行并且提示错误信息的这个动作,我们通常称之为:抛出(raise)异常
         捕获异常: 如果不能确定某些代码的执行不能确定是否正确,可以增加try(尝试)来捕获异常;
                  #eg:try:
                          #尝试执行的代码
                      except:
                          #出现错误的处理
         错误类型的捕获: 在程序执行时,可能会遇到不同类型的异常,并且需要根据不同的异常,做出不同的响应,就要用到捕获错误类型了;
                        语法:try:
                                 #尝试执行的代码
                             except 错误类型1:
                                 #针对错误类型1,对应的代码处理
                             except (错误类型2,错误类型3):
                                 #针对错误类型2和3,对应的代码处理
                             except Exception as result:
                                 print("未知错误%s" % result)
         完整的捕获异常代码语法:try:
                                 #尝试执行的代码
                             except 错误类型1:
                                 #针对错误类型1,对应的代码处理
                             except (错误类型2,错误类型3):
                                 #针对错误类型2和3,对应的代码处理
                             except Exception as result:
                                 print("未知错误%s" % result)
                             else:
                                 #没有异常才会执行的代码
                             finally:
                                 #无论是否有异常,都会执行的代码
         抛出raise异常: 在开发中,除了代码执行出错Python解释器会抛出异常之外,还可以根据应用程序特有的业务需求主动抛出异常;
                       eg: def input_password():
                                 #1.提示用户输入密码
                                 pwd = input("请输入密码: ")
                                 #2.判断密码长度,如果长度>=8,返回用户输入的密码
                                 if len(pwd) >= 8:
                                     return pwd
                                 #3.密码长度不够,需要抛出异常
                                 #4.创建异常对象,使用异常的错误信息字符串作为参数
                                 ex = Exception("密码长度不够")
                                 #5.抛出异常对象
                                 raise ex
                            try:
                                 user_pwd = input_password()
                                 print(user_pwd)
                            except Exception as result:
                                 print("发现错误: %s"% result)
           自定义异常: 自己定义的异常类,对异常进行分门别类管理,自定义异常需要继承父类异常Exception一个例子
                      eg: class MyException(Exception):
                                 def __init__(self,name,age):
                                      self.name = name
                                      self.age = age
                          try:
                                 #主动抛出异常,就是实例化一个异常
                                 raise MyException("xxx",18)                 #实例化一个异常,实例化的时候需要传参数
                          except MyException as obj:                         #体现一个封装
                                 print(obj.age,obj.name)                     #这里捕获的就是MyException类携带过来的信息
                          
                          except Exception as obj:                           #万能捕获,之前可能捕获不到,这里添加Exception作为保障
                                 print(obj)

文件:文件的概念和作用: 计算机的文件,就是储存在硬盘的数据
     文件的储存方式: 在计算机中,文件是以二进制的方式保存在磁盘上的
     文本文件: 可以使用文本编辑器查看,本质上时二进制文件;eg: python的源程序
     二进制文件: 不可以使用文本编辑器查看,保存的内容不是给人直接阅读的,而是提供给其他软件使用的;eg: 图片文件,音频文件,视频文件等;
     文件的基本操作: 计算机中操作文件的套路很固定,一般三个步骤: 1.打开文件 2.读、写文件;读:将内容读入内存;写:将内存内容写入文件;
                                                           3.关闭文件
     操作文件的函数/方法: 1.open(函数):打开文件,并且返回文件操作对象 2.read:将文件内容读取到内存 3.write:将指定内容写入文件 4.close:关闭文件
     read方法读取文件: read方法可以一次性读入并返回文件的所有内容,如果要读中文文件的话加"utf-8"编码就可以解决了
     write方法写入文件: open里面加入"w"就可以调用wirte,写法很简单,在write方法里写上想写的东西就好了
     close方法关闭文件: 如果不用close关闭文件的话,对多个文档进行操作的时候会出现奇奇怪怪的错误
     read(),readline(),readlines()的区别和用法:read([size])如果无size限制,read一次会读整个文件
                                              readline()每次只读一行,占内存少,适合大文件,返回一个字符串
                                              readlines()读取文件的所有行,放入一个列表中,每一行作为一个元素,但是读大文件会比较占内存
                     k                         !最简单,最快速的逐行处理文本的方法: 直接for循环文件对象
     with open () as读写文件: 用这种方法读文件的话可以不用写close()方法
     文件指针: 文件打开时指针一般在开头,如果用了read方法的话,指针就会到末尾;
              !控制指针的移动方法, seek()方法,参照物有三个取值:1.0:参照文件的开头 2.1:参照当前文件指针所在的位置3.2:参照文件的末尾
              seek(0,2)迅速移动到文件的末尾 seek(9,1)从当前指针位置移动9个字节 seek(6,0)从开头移动6个字节
     打开文件方式的总结: r: 以只读方式打开文件,文件指针会放在文件开头,如果文件不存在抛出异常;
                        w: 以只写的方式打开文件,如果文件存在则覆盖,不存在就创建新文件;
                        a: 以追加的方式打开文件,如果文件存在,文件指针将会放在文件的结尾,如果不存在就创建新文件;
                        r+: 以读写的方式打开文件,文件指针会放在文件开头,如果文件,不存在抛出异常;
                        w+: 以读写的方式打开文件,如果文件存在则覆盖,不存在就创建新文件;
                        a+: 以读写的方式打开文件,如果文件存在,文件指针将会放在文件的结尾,如果不存在就创建新文件;
                        rb,rb+,wb,wb+,ab,ab+: 读二进制文件
                        rt,rt+,wt,wt+,at,at+: 读文本文件 等价于r,r+,w,w+,a,a+
                        可以用for遍历枚举的方法添加行号

常用模块:1.时间处理模块: time.time()获取当前的时间的时间戳(1970纪元后经过的浮点秒数)#需要导入time模块
                       time模块侧重于时间戳的处理,所以出现了datetime模块,相当于time的高级封装,提供了
                       更多关于日期处理的方法,且更直观,方便;
                       datetime的五个主要模块:1.datetime.date: 表示日期的类,常用属性:year,month,day
                                             2.datetime.time: 表示时间的类,常用属性:hour,minute,second,microsencond
                                             3.datetime.datetime: 表示日期+时间
                                             4.datetime.timedelta: 表示时间间隔,两个时间点的长度,常用来做时间的加减
                                             5.datetime.tzinfo: 与时区有关的相关信息
                       ps: datetime中用的最多的是datetime.datetime模块,datetime.timedelta模块常用来修改时间
                       datetime.datetime中year,month,day是必须参数
                       datetime的类方法: datetime.datetime.today() #获取今天的时间
                                         datetime.datetime.now()   #获取现在的时间
                                         datetime.datetime.fromtimestamp()   #括号里写时间戳,用时间戳来生成对应的日期时间
                                         datetime.datetime.now().timestamp() #现在日期改成时间戳,其他同理
                                         datetime.datetime.now().weekday()   #获取现在对应的星期号,其他同理
                                         datetime.datetime.now()+datetime.timedelta(weeks= 3) #三周后,用datetime.timedelta改变
                                         时间,最大单位是weeks,最小是seconds
                                         strftime(): 把datetime转换成字符串,是datetime对象的实例方法;格式如下:
                                         datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")
                                         strptime(): 把字符串转换成datetime格式;格式如下:
                                         datetime.datetime.strptime('2019-07-30 19:46:36','%Y-%m-%d %H:%M:%S')#必须有两个参数
                                         所有的格式化符号:
                                         %y 两位数的年份表示(00-99)
                                         %Y 四位数的年份表示(000-9999)
                                         %m 月份(01-12)
                                         %d 月内的一天(0-31)
                                         %H 24小时制小时数(0-23)
                                         %I 12小时制小时数(1-12)
                                         %M 分钟数(00-59)
                                         %S 秒数(00-59)
                                         %a 本地简化的星期名称(Mon-Fri)
                                         %A 本地完整的星期名称(Monday-Friday)
                                         %b 本地简化的月份名称(Jan-Dec)
                                         %B 本地完整的月份名称(January-December)
                                         %c 本地相应的日期表示和时间表示
                                         %j 年内的一天(001-366)
                                         %p 本地A.M.或P.M.的等价符
                                         %U 一年中的星期数(00-53)星期天为星期的开始
                                         %w 星期(0-6),星期天为星期的开始
                                         %W 一年中的星期数(00-53)星期一为星期的开始
                                         %x 本地相应的日期表示
                                         %X 本地相应的时间表示
                                         %Z 当前时区的名称
                                         %% %本身
        
        2.目录操作模块: 1.获取当前工作目录     #导入模块sys 格式: sys.path[0]
                       2.获取执行命令的位置   #导入模块os  格式: os.getcwd()
                       3.路径拼接            #导入模块os  格式: os.path.join("/Users/pangao/text.txt")
                       4.路径拆分            #导入模块os  格式: os.path.split("/Users/pangao/text.txt")
                                                         os.path.splitext("/Users/pangao/text.txt")#直接获取文件拓展名
                                                         #合并和拆分不会检测路径是否存在,仅仅对字符串做操作
                       5.文件重命名          #导入模块os  格式: os.rename("test.txt","test.py")
                       6.删除文件            #导入模块os  格式: os.remove("test.txt")
                       7.复制文件            #导入模块shutil 格式:shutil.copyfile("test.txt","test.py")
                       8.遍历文件夹内的文件   1. #导入模块os   格式: for filename in os.listdir("./"):#获取当前目录下的文件和文件夹
                                                                    print (filename)
                                                                    
                                            2. #导入模块glob 格式: for filename in glob.glob("*.py"):#可以设置文件过滤
                                                                     print(filename)
                                                                     
                                            3. #导入模块os   格式: for fpathe,dirs,fs in os.walk("./"):#可以访问子文件夹
                                                                      print(fpathe)
                                                                      print(dirs)
                                                                      print(fs)
                                                                      for f in fs:
                                                                             print(os.path.join(fpathe,f))
                                                                             
        3.随机数模块:  1) 随机小数
                         random.random() #获取大于0且小于1 之间的小数
                         random.uniform(a,b) #获取大于等于a小于等于b的小数,如果a > b则取值取大于等于b小于等于a的小数
                      2) 随机整数
                         random.randint(a,b) #获取a到b之间的整数包括a,b
                         random.randrange(a,b) #获取a到b之间的整数不包括b
                         random.randrange(a,b,2) #获取a到b之间的奇数不包括b
                      3) 随机选择一个返回值
                         random.choice([1,"23",[4,5]]) # 返回1或者"23"或者[4,5]
                      4) 随机选择多个返回值,返回的个数为函数的第二个参数
                         random.sample([1,"23",[4,5]],2) # 返回列表元素任意2个组合作为一个列表
                      5) 打乱顺序排序
                         random.shuffle(list)  #打乱列表list中的元素顺序  
                                                                      
        4.Collections模块: 1) defaultdict(#dict子类调用工厂函数来提供缺失值)
                              作用: 创建查询不到key值的时候不会报错的dict
                              格式: person = defaultdict(lambda : "Key Not Found")#相当于给字典所有键一个默认值
                                                                                  #括号里也可以是列表等等
                           2) counter(#给对象计数)
                              格式: Counter()#括号内一般写list,tuple可具有重复元素的数据
                              
                           3) deque(#类似于列表的容器,可以从两端操作)
                              格式: 添加了.appendleft(),.popleft(),.extendleft()方法,可以从左端填入
                                    还有 maxlen=9 列表内最大长度9
                                    
                           4) namedtuple(用于创建具有命名字段的元组子类的工厂函数)
                           
                           5) orderedDict(记录输入顺序的字典)
                              格式: from collections import OrderedDict
                              #导入包后 字典顺序按照写的顺序固定排序
                              eg: from collections import OrderedDict
                                  d = {}
                                  d["a"] = 1
                                  d["b"] = 2
                                  d["c"] = 3
                                  d["d"] = 4
                                  print(d)  → OrderedDict([("a",1),("b",2),("c",3),("d",4)])
         5.pickle模块:python对象的序列化和反序列化;
                 特点:1.只能在python中使用,只支持python的基本数据类型;2.可以处理复杂的序列化语法.(eg:自定义的类的方法,游戏的存档等)
                 一.内存中操作: dumps方法将对象传成字节(序列化)loads方法将字节还原为对象(反序列化)
                 eg:import pickle
                    #dumps
                    li = [11,22,33]
                    r = pickle.dumps(li)
                    print(r)
                    
                    #loads
                    result = pickle.loads(r)
                    print(result)
                 二.文件中操作:
                 eg:#dump
                    import pickle
                    li = [11,22,33]
                    pickle.dump(li,open('db','wb'))
                    
                    #load
                    ret = pickle.load(open('db','rb'))
                    print(ret)

深拷贝,浅拷贝:浅拷贝只拷贝最外层对象,深拷贝递归拷贝内层对象
             无论是浅拷贝还是深拷贝,只拷贝可变对象成为一个新对象,不可变对象还是原来那个,不生成新对象
             当顶层对象和它的子元素全是不可变对象时,因为没有产生新对象,所以不存在被拷贝
             
             浅拷贝:1.顶层可变,内部全部不可变的时候,顶层id不同,内部id相同,当拷贝后的东西内部值改变后,拷贝前的不变,
                      拷贝前的东西内部值改变后,拷贝后的也不变
                   2.顶层可变,内部部分可变,当可变的改变时,拷贝后的会跟着改变,改变不可变的还是不变
                   3.顶部不可变,内部也不管是否可变,都不拷贝,改变拷贝后的值,拷贝前的值也会变
             
             深拷贝:1.顶层可变,内部全部不可变的时候,顶层id不同,内部id相同,当拷贝后的东西内部值改变后,拷贝前的不变,
                      拷贝前的东西内部值改变后,拷贝后的也不变
                   2.顶层可变,内部部分可变,可变部分的id也不相同, 拷贝后的东西内部值改变后,拷贝前的不变,
                      拷贝前的东西内部值改变后,拷贝后的不改变
                   3.顶层不可变,内部也不可变的时候,不存在拷贝,改变拷贝后的值,拷贝前的值也会变
                   4.顶层不可变,内部部分可变的时候,内部id改变导致顶层id也改变,存在拷贝关系,改变拷贝后的值不会影响到拷贝前的值
              格式:导入copy模块: import copy:
                                a = [1,2,[3]]
                                #浅拷贝
                                b = copy.copy(a)
                                #深拷贝
                                c = copy.deepcopy(a)
      
      
                  
         

  
                                  
                                  
          
          
    
  
